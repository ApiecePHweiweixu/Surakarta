# 网络协议

## 游戏基本流程

**6路棋盘**

1. 客户端连接服务端
2. 客户端向服务端发送 `READY_OP` 表示准备就绪
3. 服务端收到两个来自不同客户端的`READY_OP`后认为选手已就绪，向客户端发送`READY_OP`表示比赛开始，对黑棋方开始计时
4. 双方轮流发送 `MOVE_OP`
5. 当一方认输、超时或违规，比赛结束
6. 服务端向败方发送 `GG_OP` 确认，向胜方发送`END_OP`表示游戏结束，可以离开
7. 败方回复 `GG_OP` 确认（没有规定败方否认时的操作，所以此时你们应该用 `聊天功能` 来协调解决）
8. 任意一方发送 `LEAVE_OP` 后，可以断开连接（在这之前保持连接）或 **任意一方**发送 `READY_OP` 请求再来一局，相当于做了第二步

> 更具体的协议请仔细阅读以下内容，仔细按照协议通信。如果发现协议有漏洞（少考虑等），可以在 Issues 中反应，或微信和助教探讨。

## 网络协议

一个完整的请求包含一个操作符 `OP` 以及至多三个数据段 `data1` 、 `data2`和`data3`。操作符指定了当前请求需要执行的操作，数据段则在此基础上给出了一些额外信息。

下面给出本次作业中可能用到的所有请求及其处理行为，"空"代表接收方可以不处理（但也要能接受为空，不能假设这个一定有值），发送方也可以置这个数据段为空。

### `READY_OP`

即是准备，也是申请。**请求对局方**要向服务端发送自己希望执的颜色，对方同样回应 `READY_OP` 表示对局成立。

1. 建立连接成功时，客户端是请求对局方，也就是服务端在收到客户端任何通信前不与客户端进行交流。
2. 对局结束后，若需要再来一局，客户端需要向服务端再次发送`READY_OP`。

- `data1`: 己方用户名
- `data2`: 己方执棋颜色（**服务端回应该字段留空**）
- `data3`: 房间号，约定为`[0,255]`内的整数

**用户名**：只能包含英文字母大小写、数字和下划线 `_`，不得包含空格、换行符、制表符等分隔符。

**颜色编码**：黑则 "`b`"，白则 "`w`"。

**房间号**：阶段三并不要求服务端支持多房间联机，没有实现多房间服务端附加任务的小组，房间号可以默认发送`1`，规定正式比赛时房间号为`1`。

### `MOVE_OP`

决定如何行棋后，向对方发送 `MOVE_OP`

- `data1`：初始点坐标
- `data2`：移动后点坐标
- `data3`：己方落子时间戳，服务端将从这个时间戳开始计时对方的超时。

坐标编码：用 `A1`，`F6` 这种表示，坐标轴方向同 [surakarta.md](../../guidance/surakarta/surakarta.md) 中所示，双方不旋转棋盘，也就是视角是相同的。

时间戳：统一用 `QDateTime::currentMSecsSinceEpoch` 返回的结果。

> qint64 QDateTime::currentMSecsSinceEpoch()
> 
> Returns the number of milliseconds since 1970-01-01T00:00:00 Universal Coordinated Time. This number is like the POSIX time_t variable, but expressed in milliseconds instead.

时间戳意味着，假设超时时间是 3000 毫秒，例如我是黑方先手，我在发送 `MOVE_OP` 时获取当前时间是 10000（data3 的信息即设 10000），服务端的计时器就以此为头开始计时，如果 13000 这一刻服务端没有收到对方消息就判定对方超时。然后看白方，白方收到 `MOVE_OP`，data3 是 10000，但其实它收到的那一刻已经是 10500 了，但它仍然要在 13000 时保证能发到对方手中，所以你的计时器要变一下。原则上来说，你最好设倒计时剩余时间为 3000 - 2*(10500-10000)，也就是加上发回去对方收到的预计耗时。

### `GIVEUP_OP`

认输，替代 `MOVE_UP`，向对方发送 `GIVEUP_OP`

- `data1`：己方用户名（空）
- `data2`：问候语（空）
- `data3`：空

> 无处落子时及时认输才是君子之道

### `GG_OP`

`GG_OP` 并不是一个 `OP`，而是一组指定获胜原因的 `OP`。服务端向败者先发，败者回复相同操作表示确认。

- `TIMEOUT_END_OP`: 一方超时
- `SUICIDE_END_OP`: 一方落子非法：即自杀，邻移非法或**旋吃失败**
- `GIVEUP_END_OP`: 一方认输

> 如果客户端在对局中突然发送 `LEAVE_OP` 则不需要服务端回复任何信息，可以直接断开与客户端连接。

他们的数据段含义是

- `data1`：己方用户名（空）
- `data2`：问候语（空）
- `data3`：空

### `END_OP`
`END_OP`表示游戏不败结束，服务端向胜者，或平局（超过40回合没有吃子，且双方剩余棋子数目相同）时向双方发送，客户端收到后可以断开连接，或发送再来一局的准备。

数据段含义是

- `data1`: 结束原因，`s`表示一方胜利，`d`表示平局
- `data2`: 问候语（空）
- `data3`: 空

### `LEAVE_OP`

任何时候，发送 `LEAVE_OP` 说明即将立刻断开连接。

- `data1`：己方用户名（空）
- `data2`：离开的原因（空）
- `data3`：空

> 任何时候，断开前都先发 `LEAVE_OP`，以区分意外断开。接受方可以不用回复，直接断开（不用回复，但一定要断开）。
>
> 这里的“断开”需要解释一下，对于我们的网络库，你可以理解成这里只能客户端主动断开服务端（也就是接口里的 bye），然后客户端甩手就走，不管服务端愿不愿意。反过来服务端要主动和客户端断开只能约定一个协议，服务端给客户端发一个特定消息后（比如上面的 END_OP），客户端再同上主动离开（bye），然后服务端收到这个这个信号后才会离开（对应槽函数 leave）。具体的 TCP 协议怎么处理这些问题远远超过了本课要求，所以你不需要深究。
>
> 所以你实现这个操作的全过程大概会像这样：
> 
> - 客户端主动离开时先发 `LEAVE_OP` 再 `bye`，服务端收到 `bye` 后会自动触发槽函数 `leave` 断开。
> - 服务端主动断开先发 `END_OP`，客户端收到后可选地回复 `LEAVE_OP` 然后必须执行 `bye`，服务端收到 `bye` 后自动触发槽函数 `leave` 断开。注意：服务端主动断开的情况只有与胜者断开或出现平局时与双方均断开。
> - 为了简单，**你可以假设**服务端一定会收到客户端回复的 `bye`，但如果真的没收到，你可以在一开始打算主动断开时就从逻辑上断开连接，也就是以后收到这个 client 发的信号都直接 return 不处理。或者你可以自己研究网络协议和 Qt 的原始网络库设计更合理的方法来处理，但这远远超过了本课程的要求范围。

### `CHAT_OP`

只要保持连接，就可以发送 `CHAT_OP` 聊天或交换信息。

- `data1`：用户名
- `data2`：信息内容
- `data3`：空

> 上面所提到的特殊编码（颜色，坐标，用户名）均不能莫名其妙包含空格，制表符，换行等无关字符，保证编码严格统一。
